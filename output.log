Executing (default): DROP TABLE IF EXISTS "ambients_rfir_slaves_rel" CASCADE;
Executing (default): DROP TABLE IF EXISTS "ambients_rfir_devices_rel" CASCADE;
Executing (default): DROP TABLE IF EXISTS "raw_energy" CASCADE;
Executing (default): DROP TABLE IF EXISTS "ambients" CASCADE;
Executing (default): DROP TABLE IF EXISTS "scenes" CASCADE;
Executing (default): DROP TABLE IF EXISTS "rfir_buttons" CASCADE;
Executing (default): DROP TABLE IF EXISTS "rfir_commands" CASCADE;
Executing (default): DROP TABLE IF EXISTS "rfir_remotes" CASCADE;
Executing (default): DROP TABLE IF EXISTS "rfir_devices" CASCADE;
Executing (default): DROP TABLE IF EXISTS "channels" CASCADE;
Executing (default): DROP TABLE IF EXISTS "slaves" CASCADE;
Executing (default): DROP TABLE IF EXISTS "slaves" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "slaves" ("id"   SERIAL , "type" VARCHAR(255), "addr_low" INTEGER, "addr_high" INTEGER, "channels" INTEGER, "name" VARCHAR(255), "description" VARCHAR(255), PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'slaves' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "channels" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "channels" ("id"   SERIAL , "type" VARCHAR(255), "channel" INTEGER, "name" VARCHAR(255), "description" VARCHAR(255), "slave_id" INTEGER REFERENCES "slaves" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'channels' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "rfir_devices" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "rfir_devices" ("id"   SERIAL , "type" VARCHAR(255), "category" VARCHAR(255), "name" VARCHAR(255), "description" VARCHAR(255), "slave_id" INTEGER REFERENCES "slaves" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'rfir_devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "rfir_remotes" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "rfir_remotes" ("id"   SERIAL , "name" VARCHAR(255), "rfir_device_id" INTEGER REFERENCES "rfir_devices" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'rfir_remotes' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "rfir_commands" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "rfir_commands" ("id"   SERIAL , "name" VARCHAR(255), "page_low" INTEGER, "page_high" INTEGER, "rfir_device_id" INTEGER REFERENCES "rfir_devices" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'rfir_commands' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "rfir_buttons" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "rfir_buttons" ("id"   SERIAL , "name" VARCHAR(255), "indexes" VARCHAR(255), "color" INTEGER, "rfir_remote_id" INTEGER REFERENCES "rfir_remotes" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "rfir_command_id" INTEGER REFERENCES "rfir_commands" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'rfir_buttons' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "scenes" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "scenes" ("id"   SERIAL , "json" TEXT, "description" VARCHAR(255), "name" VARCHAR(255), "color" VARCHAR(255), PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'scenes' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "ambients" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "ambients" ("id"   SERIAL , "name" VARCHAR(255), "image" TEXT, PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'ambients' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "raw_energy" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "raw_energy" ("id"   SERIAL , "value" INTEGER, "datetime" INTEGER, "slave_id" INTEGER REFERENCES "slaves" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "rfir_remote_id" INTEGER REFERENCES "rfir_remotes" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'raw_energy' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "ambients_rfir_devices_rel" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "ambients_rfir_devices_rel" ("created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, "rfir_device_id" INTEGER  REFERENCES "rfir_devices" ("id") ON DELETE CASCADE ON UPDATE CASCADE, "ambient_id" INTEGER  REFERENCES "ambients" ("id") ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY ("rfir_device_id","ambient_id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'ambients_rfir_devices_rel' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): DROP TABLE IF EXISTS "ambients_rfir_slaves_rel" CASCADE;
Executing (default): CREATE TABLE IF NOT EXISTS "ambients_rfir_slaves_rel" ("created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, "slave_id" INTEGER  REFERENCES "slaves" ("id") ON DELETE CASCADE ON UPDATE CASCADE, "ambient_id" INTEGER  REFERENCES "ambients" ("id") ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY ("slave_id","ambient_id"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'ambients_rfir_slaves_rel' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
done
